# PostgreSQL MVCC (다중 버전 동시성 제어) 가이드

## 1. MVCC 소개
MVCC(Multi-Version Concurrency Control)는 PostgreSQL에서 데이터에 대한 동시 액세스를 제공하기 위해 사용하는 방법입니다. 여러 트랜잭션이 대부분의 경우 서로를 차단하지 않고 데이터베이스에 동시에 읽고 쓸 수 있도록 허용합니다.

### MVCC가 필요한 이유?
- **높은 동시성**: 읽기 작업은 쓰기 작업을 차단하지 않고, 쓰기 작업도 읽기 작업을 차단하지 않습니다.
- **일관성**: 각 트랜잭션은 트랜잭션 시작 시점의 데이터 일관성 있는 스냅샷을 봅니다.
- **성능**: 무거운 잠금의 필요성을 최소화하여 전체 시스템 처리량을 향상시킵니다.

---

## 2. 핵심 개념 및 구현
PostgreSQL에서 `UPDATE` 또는 `DELETE`가 발생할 때 기존 데이터를 덮어쓰는 대신 행(tuple)의 새 버전이 생성됩니다.

### Tuple 헤더 필드
PostgreSQL의 모든 행(tuple)은 가시성을 관리하는 숨겨진 시스템 컬럼을 포함합니다:
- **`xmin`**: 행을 삽입한 트랜잭션의 ID
- **`xmax`**: 행을 삭제한 트랜잭션의 ID. 행이 삭제되지 않은 경우 0입니다.
- **`cmin` / `cmax`**: 트랜잭션 내에서 어떤 명령이 tuple을 생성/삭제했는지 추적하는 명령 식별자

### 작동 방식 (시각적 표현)
| 트랜잭션 | 동작 | 결과 상태 |
| :--- | :--- | :--- |
| TX 100 | `INSERT` 행 A | 행 A가 `xmin=100`, `xmax=0`으로 생성됨 |
| TX 101 | `UPDATE` 행 A | 행 A의 `xmax`가 101로 설정됨. 행 A'가 `xmin=101`, `xmax=0`으로 생성됨 |
| TX 102 | `DELETE` 행 B | 행 B의 `xmax`가 102로 설정됨 |

---

## 3. 가시성 규칙
가시성(Visibility)은 특정 튜플 버전이 주어진 트랜잭션에 "보이는지" 여부를 결정합니다.

### 가시성 규칙:
1. **커밋되지 않은 변경사항**: 트랜잭션은 다른 커밋되지 않은 트랜잭션이 만든 변경사항을 볼 수 없습니다.
2. **스냅샷**: 트랜잭션은 트랜잭션(또는 문장, 격리 수준에 따라 다름)이 시작된 시점의 모든 커밋된 데이터에 대한 "스냅샷"을 봅니다.
3. **내부 변경사항**: 트랜잭션은 항상 자신의 커밋되지 않은 변경사항을 볼 수 있습니다.

### Read Committed vs Repeatable Read
- **Read Committed (기본값)**: 각 *문장*이 시작될 때 새로운 스냅샷이 생성됩니다.
- **Repeatable Read**: *첫 번째 트랜잭션 제어가 아닌 문장*이 시작될 때 하나의 스냅샷이 생성됩니다.

---

## 4. 트랜잭션 ID (XID) 래핑
PostgreSQL은 트랜잭션 ID에 대해 32비트 정수를 사용하므로, 카운터가 래핑되기 전에 약 40억 개의 트랜잭션을 처리할 수 있습니다.

### 문제점
XID가 래핑되면 매우 오래된 트랜잭션 ID가 현재 카운터와 비교했을 때 갑자기 "미래"에 있는 것처럼 보일 수 있으며, 이로 인해 오래된 데이터가 보이지 않거나 "사라질" 수 있습니다.

### 해결책: Frozen XIDs
PostgreSQL은 다른 모든 XID보다 항상 "더 오래된" 것으로 간주되는 `FrozenTransactionId`(값 2)라는 특별한 XID를 사용합니다. `VACUUM` 프로세스는 이 ID를 사용하여 오래된 튜플을 "동결"합니다.

---

## 5. VACUUM 프로세스
`UPDATE`와 `DELETE`는 디스크에 오래된 버전의 행들(dead tuples)을 남기기 때문에, 데이터베이스는 결국 공간이 부족해질 수 있습니다(Bloat).

### VACUUM의 역할:
1. **공간 회수**: Dead tuples를 제거하고 새 데이터를 위한 공간을 확보합니다.
2. **통계 업데이트**: 쿼리 플래너가 더 나은 결정을 내리도록 돕습니다.
3. **XID 래핑 방지**: 오래된 트랜잭션 ID를 동결시킵니다.

### Autovacuum
PostgreSQL은 특정 임계값을 기반으로 백그라운드에서 `VACUUM`과 `ANALYZE`를 자동으로 실행하는 `autovacuum` 데몬을 포함합니다.

---

## 6. 실용적인 예제

### 동시 업데이트 시나리오
```sql
-- 트랜잭션 1 (TX 200)
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- 트랜잭션 2 (TX 201) - TX 200이 실행 중일 때 시작됨
BEGIN;
SELECT balance FROM accounts WHERE id = 1;
-- 결과: 이전 잔액 반환 (TX 201은 TX 200의 커밋되지 않은 변경사항을 보지 못함)

COMMIT; -- TX 200 커밋
```

### 튜플 조사
MVCC 필드를 명시적으로 선택하여 볼 수 있습니다:
```sql
SELECT xmin, xmax, * FROM my_table;
```

---

## 7. 다른 동시성 방법과의 비교
| 방법 | 설명 | 장점 | 단점 |
| :--- | :--- | :--- | :--- |
| **2단계 잠금 (2PL)** | 잠금을 사용하여 동시 액세스를 방지합니다. | 일관성 구현이 간단함. | 동시성이 낮음; 교착상태 발생 가능. |
| **MVCC (PostgreSQL)** | 데이터의 여러 버전을 유지합니다. | 높은 동시성; 읽기/쓰기 차단 없음. | 스토리지 오버헤드(dead tuples); VACUUM 필요. |

---

## 8. FAQ

**Q: MVCC는 저장 공간 사용을 증가시키나요?**
A: 네, 행의 오래된 버전들이 VACUUM에 의해 정리될 때까지 유지되기 때문입니다. 이를 "테이블 블로트(Table Bloat)"라고 합니다.

**Q: 많은 삭제 작업을 했는데 데이터베이스 크기가 계속 늘어나는 이유는 무엇인가요?**
A: 삭제된 행들은 dead로 표시되지만 공간이 즉시 OS로 반환되지는 않습니다. `VACUUM`은 파일 *내부*에서 공간을 재사용 가능하게 만듭니다. OS로 공간을 반환하려면 `VACUUM FULL`을 사용하세요 (주의: 테이블을 잠급니다).

**Q: MVCC를 비활성화할 수 있나요?**
A: 아니요, MVCC는 PostgreSQL 작동의 기본이며 ACID 준수를 보장합니다.

---

## 요약
PostgreSQL의 MVCC 구현은 일관성과 성능의 균형을 맞추는 강력한 메커니즘입니다. `xmin`, `xmax`, 그리고 `VACUUM`의 필요성을 이해함으로써 개발자들은 고성능 애플리케이션을 위한 데이터베이스를 더 잘 튜닝할 수 있습니다.
